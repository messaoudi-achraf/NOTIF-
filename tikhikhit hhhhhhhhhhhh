// src/main/java/com/trading/platform/notification/config/WebSocketConfig.java
package com.trading.platform.notification.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

/**
 * Configuration WebSocket - Version simplifi√©e et corrig√©e
 */
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    /**
     * Configuration du message broker
     */
    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        // Enable simple broker pour les destinations
        config.enableSimpleBroker("/topic", "/queue");
        
        // Pr√©fixe pour les messages de l'application
        config.setApplicationDestinationPrefixes("/app");
    }

    /**
     * Configuration des endpoints STOMP
     */
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // Endpoint principal pour WebSocket
        registry.addEndpoint("/ws-notifications")
                .setAllowedOriginPatterns("*")
                .withSockJS();
        
        // Endpoint alternatif sans SockJS (optionnel)
        registry.addEndpoint("/ws-direct")
                .setAllowedOriginPatterns("*");
    }
}









// src/main/java/com/trading/platform/notification/service/WebSocketService.java
package com.trading.platform.notification.service;

import com.trading.platform.notification.entity.Notification;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

/**
 * Service WebSocket pour notifications temps r√©el - Version corrig√©e
 */
@Service
@Slf4j
public class WebSocketService {

    // Injection optionnelle pour √©viter les erreurs si WebSocket n'est pas configur√©
    @Autowired(required = false)
    private SimpMessagingTemplate messagingTemplate;

    /**
     * Broadcast notification √† tous les utilisateurs connect√©s
     */
    public void broadcastNotification(Notification notification) {
        if (messagingTemplate == null) {
            log.warn("‚ö†Ô∏è WebSocket not configured - notification {} logged only", notification.getId());
            return;
        }
        
        try {
            // Envoyer √† tous les clients connect√©s
            messagingTemplate.convertAndSend("/topic/notifications", createWebSocketMessage(notification));
            log.info("üì° WebSocket broadcast sent: {}", notification.getId());
        } catch (Exception e) {
            log.error("‚ùå WebSocket broadcast failed for notification {}: {}", notification.getId(), e.getMessage());
        }
    }

    /**
     * Envoyer notification √† un utilisateur sp√©cifique
     */
    public void sendToUser(String userId, Notification notification) {
        if (messagingTemplate == null) {
            log.warn("‚ö†Ô∏è WebSocket not configured - notification {} for user {} logged only", notification.getId(), userId);
            return;
        }
        
        try {
            // Envoyer √† un utilisateur sp√©cifique
            messagingTemplate.convertAndSendToUser(userId, "/queue/alerts", createWebSocketMessage(notification));
            log.info("üì± WebSocket sent to user {}: {}", userId, notification.getId());
        } catch (Exception e) {
            log.error("‚ùå WebSocket send to user {} failed for notification {}: {}", userId, notification.getId(), e.getMessage());
        }
    }

    /**
     * Test WebSocket
     */
    public boolean testWebSocket(String message) {
        if (messagingTemplate == null) {
            log.warn("‚ö†Ô∏è WebSocket not configured - test message logged only: {}", message);
            return false;
        }
        
        try {
            Map<String, Object> testMessage = new HashMap<>();
            testMessage.put("type", "TEST");
            testMessage.put("message", message);
            testMessage.put("timestamp", java.time.LocalDateTime.now().toString());
            testMessage.put("service", "notification-service");
            
            messagingTemplate.convertAndSend("/topic/test", testMessage);
            log.info("üß™ WebSocket test message sent: {}", message);
            return true;
        } catch (Exception e) {
            log.error("‚ùå WebSocket test failed: {}", e.getMessage());
            return false;
        }
    }

    /**
     * Cr√©er message format√© pour WebSocket
     */
    private Map<String, Object> createWebSocketMessage(Notification notification) {
        Map<String, Object> message = new HashMap<>();
        message.put("id", notification.getId());
        message.put("type", notification.getType().toString());
        message.put("priority", notification.getPriority().toString());
        message.put("title", notification.getTitle());
        message.put("message", notification.getMessage());
        message.put("status", notification.getStatus().toString());
        message.put("sourceService", notification.getSourceService());
        message.put("positionId", notification.getPositionId());
        message.put("tradeId", notification.getTradeId());
        message.put("createdAt", notification.getCreatedAt() != null ? 
                notification.getCreatedAt().toString() : null);
        message.put("timestamp", java.time.LocalDateTime.now().toString());
        
        return message;
    }
}












# src/main/resources/application.properties

# === SERVER ===
server.port=8087
spring.application.name=notification-service

# === DATABASE ===
spring.datasource.url=jdbc:postgresql://localhost:5432/trading_notifications
spring.datasource.username=postgres
spring.datasource.password=8868
spring.datasource.driver-class-name=org.postgresql.Driver

# === JPA ===
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.open-in-view=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# === EUREKA ===
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
eureka.instance.prefer-ip-address=true

# === CONFIG SERVER ===
spring.cloud.config.enabled=false

# === EMAIL (DISABLED) ===
notification.email.enabled=false

# === WEBSOCKET ===
notification.websocket.enabled=true

# === ACTUATOR ===
management.endpoints.web.exposure.include=health,info
management.endpoint.health.show-details=always

# === LOGGING ===
logging.level.com.trading.platform.notification=INFO
logging.level.org.springframework.cloud=WARN
logging.level.org.springframework.messaging=INFO

# === COMPATIBILITY ===
spring.cloud.compatibility-verifier.enabled=false











// src/main/java/com/trading/platform/notification/NotificationServiceApplication.java
package com.trading.platform.notification;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.scheduling.annotation.EnableAsync;

/**
 * Application Notification Service - Version corrig√©e
 */
@SpringBootApplication
@EnableEurekaClient
@EnableAsync
public class NotificationServiceApplication {

    public static void main(String[] args) {
        // Configuration syst√®me pour √©viter les conflits
        System.setProperty("spring.jpa.open-in-view", "false");
        
        SpringApplication.run(NotificationServiceApplication.class, args);
    }
}
