// ===================================================
// WEBSOCKET CONFIG S√âPAR√â - CORRIG√â
// ===================================================

// src/main/java/com/trading/platform/notification/config/WebSocketConfig.java
package com.trading.platform.notification.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

/**
 * Configuration WebSocket S√âPAR√âE - Version corrig√©e
 */
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    /**
     * Configuration du message broker
     */
    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        // Enable simple broker pour les destinations
        config.enableSimpleBroker("/topic", "/queue");
        
        // Pr√©fixe pour les messages de l'application
        config.setApplicationDestinationPrefixes("/app");
        
        // SUPPRIM√â: setUserDestinationPrefixes car m√©thode inexistante dans certaines versions
        // La gestion des utilisateurs se fait automatiquement avec /user
    }

    /**
     * Configuration des endpoints STOMP
     */
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // Endpoint principal pour WebSocket
        registry.addEndpoint("/ws-notifications")
                .setAllowedOriginPatterns("*")
                .withSockJS();
        
        // Endpoint alternatif sans SockJS (optionnel)
        registry.addEndpoint("/ws-direct")
                .setAllowedOriginPatterns("*");
    }

    /**
     * Bean SimpMessagingTemplate pour injection
     */
    @Bean
    public SimpMessagingTemplate messagingTemplate() {
        return new SimpMessagingTemplate(clientOutboundChannel());
    }
    
    /**
     * Channel pour messages sortants
     */
    @Bean
    public org.springframework.messaging.MessageChannel clientOutboundChannel() {
        return new org.springframework.messaging.support.ExecutorSubscribableChannel();
    }
}










// ===================================================
// WEB CONFIG S√âPAR√â - SANS WEBSOCKET
// ===================================================

// src/main/java/com/trading/platform/notification/config/WebConfig.java
package com.trading.platform.notification.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * Configuration Web S√âPAR√âE - Sans WebSocket
 */
@Configuration
public class WebConfig implements WebMvcConfigurer {

    /**
     * Configuration CORS pour API REST
     */
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // Configuration CORS pour les API REST
        registry.addMapping("/api/**")
                .allowedOriginPatterns("*")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
        
        // Configuration CORS pour WebSocket
        registry.addMapping("/ws-notifications/**")
                .allowedOriginPatterns("*")
                .allowCredentials(true);
        
        // Configuration CORS globale
        registry.addMapping("/**")
                .allowedOriginPatterns("*")
                .allowedMethods("*")
                .allowedHeaders("*")
                .allowCredentials(true);
    }

    /**
     * RestTemplate avec Load Balancer pour communication inter-services
     */
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}





// ===================================================
// WEBSOCKET SERVICE - VERSION COMPL√àTE CORRIG√âE
// ===================================================

// src/main/java/com/trading/platform/notification/service/WebSocketService.java
package com.trading.platform.notification.service;

import com.trading.platform.notification.entity.Notification;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

/**
 * Service WebSocket pour notifications temps r√©el - Version compl√®te
 */
@Service
@Slf4j
public class WebSocketService {

    @Autowired(required = false)
    private SimpMessagingTemplate messagingTemplate;

    /**
     * Broadcast notification √† tous les utilisateurs connect√©s
     */
    public void broadcastNotification(Notification notification) {
        if (messagingTemplate == null) {
            log.warn("‚ö†Ô∏è WebSocket not configured - notification {} logged only", notification.getId());
            return;
        }
        
        try {
            // Envoyer √† tous les clients connect√©s
            messagingTemplate.convertAndSend("/topic/notifications", createWebSocketMessage(notification));
            log.info("üì° WebSocket broadcast sent: {}", notification.getId());
        } catch (Exception e) {
            log.error("‚ùå WebSocket broadcast failed for notification {}: {}", notification.getId(), e.getMessage());
        }
    }

    /**
     * Envoyer notification √† un utilisateur sp√©cifique
     */
    public void sendToUser(String userId, Notification notification) {
        if (messagingTemplate == null) {
            log.warn("‚ö†Ô∏è WebSocket not configured - notification {} for user {} logged only", notification.getId(), userId);
            return;
        }
        
        try {
            // Envoyer √† un utilisateur sp√©cifique
            messagingTemplate.convertAndSendToUser(userId, "/queue/alerts", createWebSocketMessage(notification));
            log.info("üì± WebSocket sent to user {}: {}", userId, notification.getId());
        } catch (Exception e) {
            log.error("‚ùå WebSocket send to user {} failed for notification {}: {}", userId, notification.getId(), e.getMessage());
        }
    }

    /**
     * Envoyer alerte critique (priorit√© haute)
     */
    public void sendCriticalAlert(Notification notification) {
        if (messagingTemplate == null) {
            log.warn("‚ö†Ô∏è WebSocket not configured - critical alert {} logged only", notification.getId());
            return;
        }
        
        try {
            // Envoyer sur canal critique
            messagingTemplate.convertAndSend("/topic/critical", createWebSocketMessage(notification));
            log.warn("üö® Critical alert sent via WebSocket: {}", notification.getId());
        } catch (Exception e) {
            log.error("‚ùå Critical alert WebSocket failed for notification {}: {}", notification.getId(), e.getMessage());
        }
    }

    /**
     * Test WebSocket
     */
    public boolean testWebSocket(String message) {
        if (messagingTemplate == null) {
            log.warn("‚ö†Ô∏è WebSocket not configured - test message logged only: {}", message);
            return false;
        }
        
        try {
            Map<String, Object> testMessage = new HashMap<>();
            testMessage.put("type", "TEST");
            testMessage.put("message", message);
            testMessage.put("timestamp", java.time.LocalDateTime.now().toString());
            testMessage.put("service", "notification-service");
            
            messagingTemplate.convertAndSend("/topic/test", testMessage);
            log.info("üß™ WebSocket test message sent: {}", message);
            return true;
        } catch (Exception e) {
            log.error("‚ùå WebSocket test failed: {}", e.getMessage());
            return false;
        }
    }

    /**
     * V√©rifier si WebSocket est disponible
     */
    public boolean isWebSocketAvailable() {
        boolean available = messagingTemplate != null;
        log.debug("WebSocket availability: {}", available);
        return available;
    }

    /**
     * Cr√©er message format√© pour WebSocket
     */
    private Map<String, Object> createWebSocketMessage(Notification notification) {
        Map<String, Object> message = new HashMap<>();
        message.put("id", notification.getId());
        message.put("type", notification.getType().toString());
        message.put("priority", notification.getPriority().toString());
        message.put("title", notification.getTitle());
        message.put("message", notification.getMessage());
        message.put("status", notification.getStatus().toString());
        message.put("sourceService", notification.getSourceService());
        message.put("positionId", notification.getPositionId());
        message.put("tradeId", notification.getTradeId());
        message.put("createdAt", notification.getCreatedAt() != null ? 
                notification.getCreatedAt().toString() : null);
        message.put("timestamp", java.time.LocalDateTime.now().toString());
        
        return message;
    }

    /**
     * Envoyer statistiques en temps r√©el
     */
    public void sendStats(Map<String, Object> stats) {
        if (messagingTemplate == null) {
            log.debug("WebSocket not configured - stats not sent");
            return;
        }
        
        try {
            messagingTemplate.convertAndSend("/topic/stats", stats);
            log.debug("üìä Stats sent via WebSocket");
        } catch (Exception e) {
            log.error("‚ùå Stats WebSocket failed: {}", e.getMessage());
        }
    }

    /**
     * Envoyer message de connexion/d√©connexion de service
     */
    public void sendServiceStatus(String serviceName, String status) {
        if (messagingTemplate == null) {
            return;
        }
        
        try {
            Map<String, Object> statusMessage = new HashMap<>();
            statusMessage.put("serviceName", serviceName);
            statusMessage.put("status", status);
            statusMessage.put("timestamp", java.time.LocalDateTime.now().toString());
            
            messagingTemplate.convertAndSend("/topic/service-status", statusMessage);
            log.info("üîó Service status sent via WebSocket: {} = {}", serviceName, status);
        } catch (Exception e) {
            log.error("‚ùå Service status WebSocket failed: {}", e.getMessage());
        }
    }
}

